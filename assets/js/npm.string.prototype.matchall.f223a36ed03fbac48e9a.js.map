{"version":3,"sources":["webpack:///./node_modules/string.prototype.matchall/regexp-matchall.js","webpack:///./node_modules/string.prototype.matchall/auto.js","webpack:///./node_modules/string.prototype.matchall/helpers/RegExpStringIterator.js","webpack:///./node_modules/string.prototype.matchall/shim.js","webpack:///./node_modules/string.prototype.matchall/polyfill.js","webpack:///./node_modules/string.prototype.matchall/helpers/hidden.js","webpack:///./node_modules/string.prototype.matchall/implementation.js"],"names":["ES","__webpack_require__","flagsGetter","RegExpStringIterator","OrigRegExp","RegExp","regexMatchAll","string","R","this","Type","TypeError","S","ToString","tmp","C","matcher","flags","Get","source","constructRegexWithFlags","SpeciesConstructor","lastIndex","ToLength","Set","global","fullUnicode","CreateRegExpStringIterator","indexOf","defineP","Object","defineProperty","gOPD","getOwnPropertyDescriptor","desc","configurable","value","module","exports","define","GetIntrinsic","hasSymbols","hidden","set","IteratorPrototype","prototype","ObjectCreate","next","O","has","get","CreateIterResultObject","undefined","match","RegExpExec","thisIndex","nextIndex","AdvanceStringIndex","Symbol","toStringTag","enumerable","writable","iterator","func","predicate","getPolyfill","polyfill","String","matchAll","symbol","implementation","symbolCache","makeKey","prop","obj","key","supportsDescriptors","regexp","RequireObjectCoercible","GetMethod","IsRegExp","Call","rx","Invoke"],"mappings":"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","file":"assets/js/npm.string.prototype.matchall.f223a36ed03fbac48e9a.js","sourcesContent":["'use strict';\n\nvar ES = require('es-abstract');\nvar flagsGetter = require('regexp.prototype.flags');\n\nvar RegExpStringIterator = require('./helpers/RegExpStringIterator');\nvar OrigRegExp = RegExp;\n\nvar CreateRegExpStringIterator = function CreateRegExpStringIterator(R, S, global, fullUnicode) {\n\tif (ES.Type(S) !== 'String') {\n\t\tthrow new TypeError('\"S\" value must be a String');\n\t}\n\tif (ES.Type(global) !== 'Boolean') {\n\t\tthrow new TypeError('\"global\" value must be a Boolean');\n\t}\n\tif (ES.Type(fullUnicode) !== 'Boolean') {\n\t\tthrow new TypeError('\"fullUnicode\" value must be a Boolean');\n\t}\n\n\tvar iterator = new RegExpStringIterator(R, S, global, fullUnicode);\n\treturn iterator;\n};\n\nvar constructRegexWithFlags = function constructRegex(C, R) {\n\tvar matcher;\n\tvar flags = ES.Get(R, 'flags');\n\tif (typeof flags === 'string') {\n\t\tmatcher = new C(R, flags);\n\t} else if (C === OrigRegExp) {\n\t\t// workaround for older engines that lack RegExp.prototype.flags\n\t\tflags = flagsGetter(R);\n\t\tmatcher = new C(R.source, flags);\n\t} else {\n\t\tflags = flagsGetter(R);\n\t\tmatcher = new C(R, flags);\n\t}\n\treturn { flags: flags, matcher: matcher };\n};\n\nvar regexMatchAll = function SymbolMatchAll(string) {\n\tvar R = this;\n\tif (ES.Type(R) !== 'Object') {\n\t\tthrow new TypeError('\"this\" value must be an Object');\n\t}\n\tvar S = ES.ToString(string);\n\tvar C = ES.SpeciesConstructor(R, OrigRegExp);\n\n\tvar tmp = constructRegexWithFlags(C, R);\n\t// var flags = ES.ToString(ES.Get(R, 'flags'));\n\tvar flags = tmp.flags;\n\t// var matcher = ES.Construct(C, [R, flags]);\n\tvar matcher = tmp.matcher;\n\n\tvar lastIndex = ES.ToLength(ES.Get(R, 'lastIndex'));\n\tES.Set(matcher, 'lastIndex', lastIndex, true);\n\tvar global = flags.indexOf('g') > -1;\n\tvar fullUnicode = flags.indexOf('u') > -1;\n\treturn CreateRegExpStringIterator(matcher, S, global, fullUnicode);\n};\n\nvar defineP = Object.defineProperty;\nvar gOPD = Object.getOwnPropertyDescriptor;\n\nif (defineP && gOPD) {\n\tvar desc = gOPD(regexMatchAll, 'name');\n\tif (desc && desc.configurable) {\n\t\tdefineP(regexMatchAll, 'name', { value: '[Symbol.matchAll]' });\n\t}\n}\n\nmodule.exports = regexMatchAll;\n","'use strict';\n\nrequire('./shim')();\n","'use strict';\n\nvar define = require('define-properties');\nvar ES = require('es-abstract');\nvar GetIntrinsic = require('es-abstract/GetIntrinsic');\nvar hasSymbols = require('has-symbols')();\n\nvar hidden = require('./hidden')();\nvar undefined; // eslint-disable-line no-shadow-restricted-names\n\nvar RegExpStringIterator = function RegExpStringIterator(R, S, global, fullUnicode) {\n\tif (ES.Type(S) !== 'String') {\n\t\tthrow new TypeError('S must be a string');\n\t}\n\tif (ES.Type(global) !== 'Boolean') {\n\t\tthrow new TypeError('global must be a boolean');\n\t}\n\tif (ES.Type(fullUnicode) !== 'Boolean') {\n\t\tthrow new TypeError('fullUnicode must be a boolean');\n\t}\n\thidden.set(this, '[[IteratingRegExp]]', R);\n\thidden.set(this, '[[IteratedString]]', S);\n\thidden.set(this, '[[Global]]', global);\n\thidden.set(this, '[[Unicode]]', fullUnicode);\n\thidden.set(this, '[[Done]]', false);\n};\n\nvar IteratorPrototype = GetIntrinsic('%IteratorPrototype%', true);\nif (IteratorPrototype) {\n\tRegExpStringIterator.prototype = ES.ObjectCreate(IteratorPrototype);\n}\n\ndefine(RegExpStringIterator.prototype, {\n\tnext: function next() {\n\t\tvar O = this;\n\t\tif (ES.Type(O) !== 'Object') {\n\t\t\tthrow new TypeError('receiver must be an object');\n\t\t}\n\t\tif (\n\t\t\t!(O instanceof RegExpStringIterator)\n\t\t\t|| !hidden.has(O, '[[IteratingRegExp]]')\n\t\t\t|| !hidden.has(O, '[[IteratedString]]')\n\t\t\t|| !hidden.has(O, '[[Global]]')\n\t\t\t|| !hidden.has(O, '[[Unicode]]')\n\t\t\t|| !hidden.has(O, '[[Done]]')\n\t\t) {\n\t\t\tthrow new TypeError('\"this\" value must be a RegExpStringIterator instance');\n\t\t}\n\t\tif (hidden.get(O, '[[Done]]')) {\n\t\t\treturn ES.CreateIterResultObject(undefined, true);\n\t\t}\n\t\tvar R = hidden.get(O, '[[IteratingRegExp]]');\n\t\tvar S = hidden.get(O, '[[IteratedString]]');\n\t\tvar global = hidden.get(O, '[[Global]]');\n\t\tvar fullUnicode = hidden.get(O, '[[Unicode]]');\n\t\tvar match = ES.RegExpExec(R, S);\n\t\tif (match === null) {\n\t\t\thidden.set(O, '[[Done]]', true);\n\t\t\treturn ES.CreateIterResultObject(undefined, true);\n\t\t}\n\t\tif (global) {\n\t\t\tvar matchStr = ES.ToString(ES.Get(match, '0'));\n\t\t\tif (matchStr === '') {\n\t\t\t\tvar thisIndex = ES.ToLength(ES.Get(R, 'lastIndex'));\n\t\t\t\tvar nextIndex = ES.AdvanceStringIndex(S, thisIndex, fullUnicode);\n\t\t\t\tES.Set(R, 'lastIndex', nextIndex, true);\n\t\t\t}\n\t\t\treturn ES.CreateIterResultObject(match, false);\n\t\t}\n\t\thidden.set(O, '[[Done]]', true);\n\t\treturn ES.CreateIterResultObject(match, false);\n\t}\n});\nif (hasSymbols) {\n\tvar defineP = Object.defineProperty;\n\tif (Symbol.toStringTag) {\n\t\tif (defineP) {\n\t\t\tdefineP(RegExpStringIterator.prototype, Symbol.toStringTag, {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: false,\n\t\t\t\tvalue: 'RegExp String Iterator',\n\t\t\t\twritable: false\n\t\t\t});\n\t\t} else {\n\t\t\tRegExpStringIterator.prototype[Symbol.toStringTag] = 'RegExp String Iterator';\n\t\t}\n\t}\n\n\tif (!IteratorPrototype && Symbol.iterator) {\n\t\tvar func = {};\n\t\tfunc[Symbol.iterator] = RegExpStringIterator.prototype[Symbol.iterator] || function SymbolIterator() {\n\t\t\treturn this;\n\t\t};\n\t\tvar predicate = {};\n\t\tpredicate[Symbol.iterator] = function () {\n\t\t\treturn RegExpStringIterator.prototype[Symbol.iterator] !== func[Symbol.iterator];\n\t\t};\n\t\tdefine(RegExpStringIterator.prototype, func, predicate);\n\t}\n}\n\nmodule.exports = RegExpStringIterator;\n","'use strict';\n\nvar define = require('define-properties');\nvar hasSymbols = require('has-symbols')();\nvar getPolyfill = require('./polyfill');\nvar regexMatchAll = require('./regexp-matchall');\n\nvar defineP = Object.defineProperty;\nvar gOPD = Object.getOwnPropertyDescriptor;\n\nmodule.exports = function shimMatchAll() {\n\tvar polyfill = getPolyfill();\n\tdefine(\n\t\tString.prototype,\n\t\t{ matchAll: polyfill },\n\t\t{ matchAll: function () { return String.prototype.matchAll !== polyfill; } }\n\t);\n\tif (hasSymbols) {\n\t\t// eslint-disable-next-line no-restricted-properties\n\t\tvar symbol = Symbol.matchAll || (Symbol['for'] ? Symbol['for']('Symbol.matchAll') : Symbol('Symbol.matchAll'));\n\t\tdefine(\n\t\t\tSymbol,\n\t\t\t{ matchAll: symbol },\n\t\t\t{ matchAll: function () { return Symbol.matchAll !== symbol; } }\n\t\t);\n\n\t\tif (defineP && gOPD) {\n\t\t\tvar desc = gOPD(Symbol, symbol);\n\t\t\tif (!desc || desc.configurable) {\n\t\t\t\tdefineP(Symbol, symbol, {\n\t\t\t\t\tconfigurable: false,\n\t\t\t\t\tenumerable: false,\n\t\t\t\t\tvalue: symbol,\n\t\t\t\t\twritable: false\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tvar func = {};\n\t\tfunc[symbol] = RegExp.prototype[symbol] || regexMatchAll;\n\t\tvar predicate = {};\n\t\tpredicate[symbol] = function () { return RegExp.prototype[symbol] !== regexMatchAll; };\n\t\tdefine(RegExp.prototype, func, predicate);\n\t}\n\treturn polyfill;\n};\n","'use strict';\n\nvar implementation = require('./implementation');\n\nmodule.exports = function getPolyfill() {\n\treturn String.prototype.matchAll || implementation;\n};\n","'use strict';\n\nvar define = require('define-properties');\n\nmodule.exports = function getHiddenKeyManager() {\n\tvar symbolCache = {};\n\tvar makeKey = function key(prop) {\n\t\tif (symbolCache['$' + prop]) {\n\t\t\treturn symbolCache['$' + prop];\n\t\t}\n\t\tif (typeof Symbol === 'function') {\n\t\t\tsymbolCache['$' + prop] = Symbol(prop);\n\t\t\treturn symbolCache['$' + prop];\n\t\t}\n\t\treturn '___ ' + prop + ' ___';\n\t};\n\treturn {\n\t\tget: function get(obj, prop) {\n\t\t\treturn obj[makeKey(prop)];\n\t\t},\n\t\thas: function has(obj, prop) {\n\t\t\treturn makeKey(prop) in obj;\n\t\t},\n\t\tset: function set(obj, prop, value) {\n\t\t\tvar key = makeKey(prop);\n\t\t\tif (define.supportsDescriptors) {\n\t\t\t\tObject.defineProperty(obj, key, {\n\t\t\t\t\tconfigurable: false,\n\t\t\t\t\tenumerable: false,\n\t\t\t\t\tvalue: value,\n\t\t\t\t\twritable: true\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tobj[key] = value;\n\t\t\t}\n\t\t}\n\t};\n};\n","'use strict';\n\nvar ES = require('es-abstract');\nvar hasSymbols = require('has-symbols')();\n\nvar regexMatchAll = require('./regexp-matchall');\n\nmodule.exports = function matchAll(regexp) {\n\tvar O = ES.RequireObjectCoercible(this);\n\n\tif (typeof regexp !== 'undefined' && regexp !== null) {\n\t\tvar matcher;\n\t\tif (hasSymbols && typeof Symbol.matchAll === 'symbol') {\n\t\t\tmatcher = ES.GetMethod(regexp, Symbol.matchAll);\n\t\t} else if (ES.IsRegExp(regexp)) {\n\t\t\t// fallback for pre-Symbol.matchAll environments\n\t\t\tmatcher = regexMatchAll;\n\t\t}\n\t\tif (typeof matcher !== 'undefined') {\n\t\t\treturn ES.Call(matcher, regexp, [O]);\n\t\t}\n\t}\n\n\tvar S = ES.ToString(O);\n\t// var rx = ES.RegExpCreate(regexp, 'g');\n\tvar rx = new RegExp(regexp, 'g');\n\tif (hasSymbols && typeof Symbol.matchAll === 'symbol') {\n\t\treturn ES.Invoke(rx, Symbol.matchAll, [S]);\n\t}\n\t// fallback for pre-Symbol.matchAll environments\n\treturn ES.Call(regexMatchAll, rx, [S]);\n};\n"],"sourceRoot":""}